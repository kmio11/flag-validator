package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/ast/astutil"
)

const (
	inDir  = "./../../"
	outDir = "./../"

	outSuffix     = "_gen.go"
	outTestSuffix = "_gen_test.go"

	oldModName = "github.com/kmio11/flag-validator"
	newModName = "github.com/kmio11/flag-validator/pflag-validator"

	oldPackageName = "flagvalidator"
	newPackageName = "pflagvalidator"

	flagPackageName = "flag"
	pflagImportPath = "github.com/spf13/pflag"
)

type ExistingNodes struct {
	fset  *token.FileSet
	nodes map[string]*ast.Package
}

//go:generate go run github.com/kmio11/flag-validator/pflag-validator/generate
func main() {
	err := clean(outDir)
	if err != nil {
		panic(err)
	}

	existingNodes := func() *ExistingNodes {
		fset := token.NewFileSet()
		nodes, err := parser.ParseDir(fset, outDir,
			func(fi fs.FileInfo) bool {
				if strings.HasSuffix(fi.Name(), outSuffix) || strings.HasSuffix(fi.Name(), outTestSuffix) {
					return false
				}
				return strings.HasSuffix(fi.Name(), ".go")
			},
			parser.AllErrors,
		)
		if err != nil {
			panic(err)
		}
		return &ExistingNodes{
			fset:  fset,
			nodes: nodes,
		}
	}()

	entries, err := os.ReadDir(inDir)
	if err != nil {
		panic(err)
	}
	for _, ent := range entries {
		if ent.IsDir() {
			continue
		}
		if strings.HasSuffix(ent.Name(), ".go") {
			func() {
				outFile := filepath.Join(outDir, outFileName(ent.Name()))
				outFileWriter, err := os.Create(outFile)
				if err != nil {
					panic(err)
				}
				defer outFileWriter.Close()

				err = generate(outFileWriter, existingNodes, filepath.Join(inDir, ent.Name()))
				if err != nil {
					panic(err)
				}
			}()
		}
	}

}

func clean(outDir string) error {
	entries, err := os.ReadDir(outDir)
	if err != nil {
		return err
	}
	for _, ent := range entries {
		if ent.IsDir() {
			continue
		}
		if strings.HasSuffix(ent.Name(), outSuffix) || strings.HasSuffix(ent.Name(), outTestSuffix) {
			err := os.Remove(filepath.Join(outDir, ent.Name()))
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func outFileName(in string) string {
	if strings.HasSuffix(in, "_test.go") {
		return strings.Replace(in, "_test.go", outTestSuffix, 1)
	}
	return strings.Replace(in, ".go", outSuffix, 1)
}

func generate(w io.Writer, existingNodes *ExistingNodes, fileName string) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, fileName, nil, parser.AllErrors|parser.ParseComments)
	if err != nil {
		return err
	}

	// replace package name
	node.Name.Name = strings.Replace(node.Name.Name, oldPackageName, newPackageName, 1)

	_ = astutil.RewriteImport(fset, node, oldModName, newModName)

	deleted := astutil.DeleteImport(fset, node, flagPackageName)
	if deleted {
		added := astutil.AddNamedImport(fset, node, flagPackageName, pflagImportPath)
		if !added {
			return fmt.Errorf(fmt.Sprintf("failed to add pflag import to %s", fileName))
		}
	}

	// overwrite with exsiting declarations.
	astutil.Apply(node, nil, func(c *astutil.Cursor) bool {
		n := c.Node()
		switch x := n.(type) {
		case *ast.FuncDecl:
			if existingNodes.existingFunc(x) != nil {
				c.Delete()
			}
		}
		return true
	})

	//
	// output
	//
	fmt.Fprintln(w, "// Code generated by flag-validator; DO NOT EDIT.")
	format.Node(w, fset, node)
	return nil
}

func (e ExistingNodes) existingFunc(target *ast.FuncDecl) *ast.FuncDecl {
	var ret *ast.FuncDecl
	for _, node := range e.nodes {
		astutil.Apply(node, nil, func(c *astutil.Cursor) bool {
			n := c.Node()
			switch x := n.(type) {
			case *ast.FuncDecl:
				if target.Name.Name == x.Name.Name {
					if target.Recv == nil && x.Recv == nil {
						ret = x
						return true
					}
					if getRecvTypeName(target.Recv) == getRecvTypeName(x.Recv) {
						ret = x
						return true
					}
				}
			}
			return true
		})
	}
	return ret
}

func getRecvTypeName(recv *ast.FieldList) string {
	if recv == nil {
		return ""
	}
	switch x := recv.List[0].Type.(type) {
	case *ast.StarExpr:
		switch xx := x.X.(type) {
		case *ast.Ident:
			return xx.Name
		case *ast.IndexExpr:
			if xxx, ok := xx.X.(*ast.Ident); ok {
				return xxx.Name
			}
		}
	case *ast.Ident:
		return x.Name
	case *ast.IndexExpr:
		if xx, ok := x.X.(*ast.Ident); ok {
			return xx.Name
		}
	}
	return ""
}
